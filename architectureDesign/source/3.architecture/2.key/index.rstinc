关键问题及解决方案
**********************

数据上行聚合
######################

本项目将会有 **大量** 嵌入式终端, 将 **小规模** 的数据持续聚合到服务器端。

在上述场景下, 使用 ``Http`` 协议进行数据聚合将面临以下问题:

1. 处理高并发请求

常见的 ``Http`` 服务器采用多线程模型来处理入站请求。对于常规的 ``Web`` 应用，一次访问常常伴随着执行SQL语句，渲染前端页面等一系列操作，为每一次
请求分配一个线程进行处理是合情合理的。但是物联网项目中,每次请求要求的计算资源极小，而请求的频率很高；当并发数量上升时，线程上下文切换将浪费系统资源，导致性能下降

2. 过多的冗余信息

一个合法的 ``Http`` 协议请求，将一系列Key-Value以字符串的形式封装在包中作为请求 ``Header``。本项目中一次请求的数据量极小，可能会出现Header中
Value数据占用的空间还没有Key占用的空间大这样的情况。使用Http协议传输数据会将大量的带宽浪费在传输冗余的数据上。

为了避免上述问题发生，本项目使用 ``MQTT`` 协议进行数据上行聚合。``MQTT`` 能较好的解决上述两个问题

1.  常见的 ``MQTT Broker`` 并不通过多线程，而是通过异步的方式处理并发请求，因此能避免线程上下文切换带来的额外开销。
2.  ``MQTT`` 协议的数据包是以二进制形式存储数据的，可以最大化带宽利用率。

服务器推送
##############

本项目在两个场景下需要引入服务器推送的支持。

1. 服务端向用户端的推送

某些情况下 (例如 :ref:`用例:触发报警事件` ), 服务端会将数据主动推送到用户端。

2. 服务端向嵌入式终端的推送

某些情况下 (例如 :ref:`用例:操作执行器` , :ref:`用例:设置传感器报警逻辑` ), 服务端会将数据主动推送到嵌入式终端。

Http协议作为典型的C/S架构协议, 无力处理这种客户端不发送请求但需要获取数据的情形。此外 ``NAT`` 技术的广泛使用也让服务端基本不可能获得客户端的真实地址。
为了实现服务端推送，一种常见的做法是摒弃高层协议，转而使用最基本的 ``TCP Socket`` 来维护一个长连接，以实现服务器推送。

这种通过长连接，使用自定义协议实现服务器推送的方法，最大的缺点在于它会极大的增加代码的复杂性。在实现时需要考虑断线重连，虚连接等等一系列非常底层的问题。
当我们的服务对于 ``QOS`` 有要求时，复杂度会进一步上升。

在 ``Broker Pattern`` 中没有C/S架构中“请求-回复”的模式，取而代之的是“发布-订阅”的模式。这种模式最显著的特点是

1. 任何节点都可以是逻辑上数据的产生者，也可以逻辑上数据的获取者
2. 数据的产生者和数据的消费者不必知道对方的存在

综上两点原因，我们在设计阶段引入 ``Broker Pattern`` 来实现服务器推送。在 :ref:`数据上行聚合` 中也提到了我们将会用MQTT协议实现数据的聚合，而MQTT协议天生
就带有 ``Broker Pattern`` 的属性。


控制嵌入式终端状态
#####################

本项目允许用户通过某些接口更改嵌入式终端的状态 (例如 :ref:`用例:操作执行器` , :ref:`用例:设置传感器报警逻辑` )。实现这项功能的难点分别为


1. 用户端与嵌入式端并不总是能够(事实上，几乎总不能够)相互访问, 必须要通过服务端中转。
2. 更改嵌入式终端的状态是一项非常耗时的操作。即便是拨动一个继电器，硬件也需要至少100毫秒的动作时间。100毫秒的等待时间对于服务器和客户端都是非常高昂的。

为了解决上述两个问题，引入了 ``Defered RESTful`` 的概念，向传统的 ``RESTful`` 服务器中引入消息队列。


