嵌入式终端Redis
*******************************************

设计
########

该组件基本信息如下:

.. componentdetail:: redis

本系统通过使用Redis提供的订阅发布功能来实现嵌入式终端内其他组件的IPC。在部署时, 使用Redis Server为数据,事件及
命令分别建立Topic,程序中其他组件可以通过订阅Topic或向Topic中推送消息来实现相互通信。通过引入这种IPC模式, 可以

1. 降低其他组件间的耦合性

以  :component:`数据分发处理` 组件为例说明Redis是如何降低模块间的耦合性的。 该组件用于处理嵌入式终端的数据，将数据推送到远程Broker；在
数据满足某些条件时，生成系统事件并将系统事件推送到远程服务器及本地的事件处理组件。 如果没有Redis, 该模块至少需要三套接口，分别处理与 :component:`数据源`
:component:`MQTT协议代理` 和 :component:`事件处理` 之间的通信, 这使得 :component:`数据分发处理` 和这三个组件紧密的耦合在了一起，提高了
维护的复杂程度。引入Redis后，显而易见的，该模块与 :component:`事件处理` 和  :component:`数据源` 的耦合不再存在了,它们三者彼此无法感知到对方的存在；
具体实现时代码的复杂程度也得以降低，因为现在只需要处理和Redis之间的通信即可。

2. 提高组件内聚性

以 :component:`RPC执行器` 为例说明Redis是如何提高组件内聚性的。该组件会执行命令。 引入Redis后，获取命令这一操作简化为监听Redis服务器Topic.
因此实现该组件的过程中无需过多考虑从哪里以及以何种方式获得待执行的命令, 而专注于如何实现 ``执行命令`` 这一核心逻辑。

3. 提高系统的扩展性

接上述关于 :component:`RPC执行器` 的例子。事实上在当前的系统设计中，需要执行的命令主要来源于远程服务器和事件处理器。假如后期系统需要在本地接入
一些交互组件(例如键盘)来实现用户对嵌入式终端的直接控制，那么我们无需对现有的组件进行任何改动，只需要新开发一个叫做 ``本地交互组件驱动`` 的新组件，
该组件只需要将用户的操作映射为预先规定的命令格式，并发布到由Redis提供的命令Topic中，就完成了系统的扩展。

4. 简化IPC实现

在没有Redis的情况下，组件间的通信可能会通过命名管道，本地Socket或是共享内存实现。尽管它们的性能有可能高于Redis,但是使用它们将会带来极大的不便。
命名管道对通信双方的读写时序有严格的要求；本地Socket只能传输字节流，为了实现通信需要引入额外的序列化与反序列化逻辑, 此外还需要考虑TCP连接稳定性的问题
;使用共享内存则需要通过同步原语构造复杂的逻辑来保证数据访问不会冲突。引入Redis将大大的简化IPC的实现。Redis本身支持丰富的数据类型，因此可以不用
考虑序列化/反序列化的问题；订阅发布的模式则让实现无需考虑同步的问题。
